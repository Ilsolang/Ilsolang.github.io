{
    "version": "https://jsonfeed.org/version/1",
    "title": "Ilya Semenov",
    "home_page_url": "http://localhost:4000/",
    "feed_url": "http://localhost:4000/feed.json",
    "description": "I am a Data Science student with a strong passion for data and artificial intelligence.  During my spare time I devour books and I always try to study and learn new things.  I am fascinated by the world of productivity and investements.  Well, I wish I have 48 hours per day, but I have to settle for 24!",
    "icon": "http://localhost:4000/apple-touch-icon.png",
    "favicon": "http://localhost:4000/favicon.ico",
    "expired": false,
    
    "author":  {
        "name": "Ilya Semenov",
        "url": null,
        "avatar": null
    },
    
"items": [
    
        {
            "id": "http://localhost:4000/2021/12/06/activity",
            "title": "Activity",
            "summary": "Activity",
            "content_text": "2021      (December) : Started contributing to  ML-and-DataScience-preparation        (October) : Started an internship @ AIKO - Autonomous Space Missions        (September) : Incremental Learning for Semantic Segmentation | (repository)         (September) : Learned the basics of Fast API + tutorial | (repository)         (September) : Wrote my first article on medium! | (link)         (September) : Credit card default project | (repository)        (May - September) : Joined Tech Talents        (May - August) : Collaborated to the “ART-ificial intelligence” research project        (May - August) : Live Financial Sentiment Analysis | (repository)        (June) : Bias and Fairness detector | (repository)        (April - June) : Machine Learning Engineer @ Omdena | (certificate)        (February - May) : #66DaysOfData | (repository)        (January) : Wine Quality Prediction | (repository)  2020      (December) : Black Lives Matter Sentiment Analysis | (repository)        (September) : Started a MSc in Data Science and Engineering @ PoliTo        (July) : Graduated in Computer Engineering cum Laude @ UniPa  ",
            "content_html": "<h1 id=\"2021\">2021</h1><ul>  <li>    <p>(December) : Started contributing to  <a href=\"https://github.com/leadthefuture/ML-and-DataScience-preparation\">ML-and-DataScience-preparation</a></p>  </li>  <li>    <p>(October) : Started an internship @ <a href=\"https://www.aikospace.com\">AIKO - Autonomous Space Missions</a></p>  </li>  <li>    <p>(September) : Incremental Learning for Semantic Segmentation | <a href=\"https://github.com/francescodisalvo05/incremental-learning-semantic-segmentation\">(repository) </a></p>  </li>  <li>    <p>(September) : Learned the basics of Fast API + tutorial | <a href=\"https://github.com/francescodisalvo05/fastapi-grocery-list\">(repository) </a></p>  </li>  <li>    <p>(September) : Wrote my first article on medium! | <a href=\"https://medium.com/geekculture/curse-of-dimensionality-e97ba916cb8f\">(link) </a></p>  </li>  <li>    <p>(September) : Credit card default project | <a href=\"https://github.com/francescodisalvo05/credit-card-default\">(repository)</a></p>  </li>  <li>    <p>(May - September) : Joined Tech Talents</p>  </li>  <li>    <p>(May - August) : Collaborated to the “ART-ificial intelligence” research project</p>  </li>  <li>    <p>(May - August) : Live Financial Sentiment Analysis | <a href=\"https://github.com/daniele21/Financial_Sentiment_Analysis\">(repository)</a></p>  </li>  <li>    <p>(June) : Bias and Fairness detector | <a href=\"https://github.com/francescodisalvo05/bias-fairness-detector\">(repository)</a></p>  </li>  <li>    <p>(April - June) : Machine Learning Engineer @ Omdena | <a href=\"https://drive.google.com/file/d/10fQBl_Ka_vNTnCvq0duJIKSCbSVFWkou/view\">(certificate)</a></p>  </li>  <li>    <p>(February - May) : #66DaysOfData | <a href=\"https://github.com/francescodisalvo05/66DaysOfData\">(repository)</a></p>  </li>  <li>    <p>(January) : Wine Quality Prediction | <a href=\"https://github.com/francescodisalvo05/wine-quality-prediction\">(repository)</a></p>  </li></ul><p><br /><br /></p><h1 id=\"2020\">2020</h1><ul>  <li>    <p>(December) : Black Lives Matter Sentiment Analysis | <a href=\"https://github.com/francescodisalvo05/Twitter-Black-Lives-Matter-SA\">(repository)</a></p>  </li>  <li>    <p>(September) : Started a MSc in Data Science and Engineering @ PoliTo</p>  </li>  <li>    <p>(July) : Graduated in Computer Engineering cum Laude @ UniPa</p>  </li></ul>",
            "url": "http://localhost:4000/2021/12/06/activity",
            
            
            
            
            
            "date_published": "2021-12-06T00:00:00+00:00",
            "date_modified": "2021-12-06T00:00:00+00:00",
            
                "author":  {
                "name": "Ilya Semenov",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2021/10/03/decision-tree-random-forest-1",
            "title": "Decision Tree and Random Forest — PT 1",
            "summary": "Decision Tree and Random Forest — PT 1",
            "content_text": "Decision Tree and Random Forest — PT 1  This article is also available on medium.Tree based algorithms are probably the most used algorithms in both classification and regression problems. In fact, if you see a couple of Kaggle notebooks, it is quite easy to understand that most of the people blindly try Random Forest as a first trial.Today I would like to go deeper in this topic and try to explain what are their main advantages and disadvantages.Even though there are several tree based algorithms, most of the times we refer to Decision Tree and Random Forest.Decision TreeDecision tree is a supervised learning algorithm that predicts the new labels by recursively splitting the predictor space into non overlapping distinct regions. For every observation that falls into any region we make the same prediction, which is the majority class in that region (for classification) or the mean of the response value (for regression).Since considering every possible partition is computationally infeasible (NP- hard problem), the tree is constructed with a greedy top down approach, known as recursive binary splitting.It is top-down because it begins at the top of the tree and then it successively splits the predictor space; each split is indicated via two new branches further down on the tree. Then, it is greedy because at each step of the tree-building process, the best split is made at that particular step, rather than looking ahead and picking a split that will lead to a better tree in some future step.  Source : (link)In order to select the best split to make for classification problems, we consider the split that minimize something. Here we have two main alternatives, the Gini Index and the Entropy.The Gini Index is a measure of impurity and in particular it measures the variances across the classes. It is defined as:\\[\\mbox {Gini} = 1 - \\sum_j p_j^2\\]where j is the current class evaluated and p_j is the probability (percentage) of class j. If we have one single class in the current partition its value will be 0 (the minimum) but if we have an equally distributed number of samples, we will have a Gini index equal to 1-(1/#classes).On the other hand, the Entropy measures the so called “information gain”, defined as the disorder of the features with the current target. It is defined as:\\[\\mbox{Entropy} = \\sum_j p_j \\log_2 p_j\\]  In regression problems, we aim to minimize the RSS (Residual Sum of Squares)The main advantage of a decision tree is that it is fairly interpretable. The expanded decision tree can be easily explained if it is not too big. The problem is not only the interpretability, but huge trees could also have some redundant sub trees. Therefore, there are some techniques that allow to compress the dimensions, obtaining a less complex and less redundant tree. It can be pruned after the whole generation of the tree (post-pruning), replacing the less informative subtrees with leaves. However, the most efficient way to do that is to prune it before it grows on its entirety (pre-pruning) because it simplifies it step by step, and not in the end. The pruning can be performed for different reasons, for example we may decide to prune it if it overcomes a given threshold for the depth or for the Gini/Entropy.If we come up with a non-enormous tree, it may be also understood by non-experts. However, the disadvantages overcome the benefits and this is the reason why decision trees are barely used. In particular, the performances are not always optimal but most importantly, they are strongly affected by noise and outliers.These limitations have brought to light a more advanced tree-based algorithm, that is Random Forest, an ensemble method that combines multiple decision trees (that is why it is called “forest”) with the bagging technique, obtaining a more accurate and robust model.Random ForestThe idea of bagging is to make prediction on N bootstrapped copies of the training set (i.e. sampled with replacement). In order to decorellate the trees, feature bagging is the best option. In particular, each time a split in a tree is considered, a fixed number of features (typically √p) is randomly chosen.  p is the number of features of the given datasetThe final prediction will be given by a majority voting scheme of all the estimators (or the average, in regression tasks).This is why this algorithm is fairly robust to noise and outliers and will have much less variance rather than a single decision tree. It is robust to noise and outliers because the “impact” of these data points will be spread over all estimators and therefore their impact will decrease as the number of estimators increases. Then, it has a less variance because if we consider n observations with variance σ^2, the variance of the sample mean (over all estimators) will be exactly σ^2/n.  Random Forest (source)On average, each bagged tree uses two third of the observation, therefore the remaining one third can be used to fit the given tree in order to evaluate its performances. This error is called out of bag error and sometimes it can be used for “stopping” the training procedure.The million-dollar question is: how many trees do I need? I faced the same problem during my first trials. Intuitively, the higher is the number of estimators, the better will be the results BUT the improvements is not linear, therefore up to a certain point the computational complexity introduced will not be justified by its benefits.When I was looking for the same answer I have found this paper that conducted an analysis on 29 different datasets and showed that “from 128 trees there is no more significant difference between the forests using 256, 512, 1024, 2048 and 4096 trees”.Since we talked about the advantages we have to mention probably the main drawback : the computational cost. If we have limited resources, this algorithm may not be the perfect choice, especially if we have a large number of features and chosen estimators.ConclusionsToday we went a bit deeper on the theory behind Decision Tree and Random Forest. Assuming that we have to select one of these two algorithms, we could say in a couple of lines that Decision Tree could be a valid option if we need to explain our model to non-experts or if we want to understand a bit what is going on inside our model. But, if we care only about the overall performances and we do not have any particular computational limitations, Random Forest should be preferred.This was just the first part and soon or later I will post the second one, from which we will go through the implementation of both algorithms!Thanks for reading the whole post and I hope it is all clear. If you still have some doubts or if you wanna just drop me a message, I would be more than happy to read it! Feel free to contact me on LinkedIn :)References  Wallpaper : https://unsplash.com/photos/7EqQ1s3wIAI  Gini vs Entropy : https://en.wikipedia.org/wiki/Recursive_partitioning  Bagging vs Boosting : https://quantdare.com/what-is-the-difference-between-bagging-and-boosting/  Number of trees in RF : https://www.researchgate.net/publication/230766603_How_Many_Trees_in_a_Random_Forest",
            "content_html": "<h1 id=\"decision-tree-and-random-forest--pt-1\">Decision Tree and Random Forest — PT 1</h1><p><img src=\"http://localhost:4000/assets/images/decision-tree-random-forest/wallpaper.jpg\" alt=\"Wallpaper\" /></p><blockquote>  <p>This article is also available on <a href=\"https://medium.com/@francesco.disalvo/decision-tree-and-random-forest-pt-1-729b74db1756\">medium</a>.</p></blockquote><p>Tree based algorithms are probably the most used algorithms in both classification and regression problems. In fact, if you see a couple of Kaggle notebooks, it is quite easy to understand that most of the people blindly try <strong>Random Forest</strong> as a first trial.</p><p>Today I would like to go deeper in this topic and try to explain what are their main advantages and disadvantages.</p><p>Even though there are several tree based algorithms, most of the times we refer to <strong>Decision Tree</strong> and <strong>Random Forest</strong>.<br /><br /></p><h2 id=\"decision-tree\">Decision Tree</h2><p><strong>Decision tree</strong> is a <strong>supervised learning</strong> algorithm that predicts the new labels by <strong>recursively splitting</strong> the predictor space into <strong>non overlapping</strong> distinct regions. For every observation that falls into any region we make the same prediction, which is the <strong>majority class</strong> in that region (for classification) or the <strong>mean</strong> of the response value (for regression).</p><p>Since considering every possible partition is computationally infeasible (<strong>NP- hard problem</strong>), the tree is constructed with a <strong>greedy top down approach</strong>, known as recursive binary splitting.</p><p>It is top-down because it begins at the top of the tree and then it successively splits the predictor space; each split is indicated via two new branches further down on the tree. Then, it is greedy because at each step of the tree-building process, the best split is made at that particular step, rather than looking ahead and picking a split that will lead to a better tree in some future step.</p><p><img src=\"http://localhost:4000/assets/images/decision-tree-random-forest/splitting.jpeg\" alt=\"BinarySplitting\" /></p><blockquote>  <p>Source : (<a href=\"https://tex.stackexchange.com/questions/526560/plotting-regression-tree-and-partitions\">link</a>)</p></blockquote><p>In order to select the best split to make for classification problems, we consider the split that minimize something. Here we have two main alternatives, the <strong>Gini Index</strong> and the <strong>Entropy</strong>.</p><p>The Gini Index is a measure of impurity and in particular it measures the variances across the classes. It is defined as:</p>\\[\\mbox {Gini} = 1 - \\sum_j p_j^2\\]<p>where j is the current class evaluated and p_j is the probability (percentage) of class j. If we have one single class in the current partition its value will be 0 (the minimum) but if we have an equally distributed number of samples, we will have a Gini index equal to 1-(1/#classes).</p><p>On the other hand, the Entropy measures the so called “information gain”, defined as the disorder of the features with the current target. It is defined as:</p>\\[\\mbox{Entropy} = \\sum_j p_j \\log_2 p_j\\]<blockquote>  <p>In regression problems, we aim to minimize the RSS (Residual Sum of Squares)</p></blockquote><p>The main <strong>advantage</strong> of a decision tree is that it is fairly <strong>interpretable</strong>. The expanded decision tree can be easily explained if it is not too big. The problem is not only the interpretability, but huge trees could also have some redundant sub trees. Therefore, there are some techniques that allow to compress the dimensions, obtaining a less complex and less redundant tree. It can be pruned after the whole generation of the tree (<strong>post-pruning</strong>), replacing the less informative subtrees with leaves. However, the most efficient way to do that is to prune it before it grows on its entirety (<strong>pre-pruning</strong>) because it simplifies it step by step, and not in the end. The pruning can be performed for different reasons, for example we may decide to prune it if it overcomes a given threshold for the depth or for the Gini/Entropy.</p><p>If we come up with a non-enormous tree, it may be also understood by non-experts. However, the <strong>disadvantages</strong> overcome the benefits and this is the reason why decision trees are barely used. In particular, the performances are not always optimal but most importantly, they are strongly affected by <strong>noise</strong> and <strong>outliers</strong>.</p><p>These limitations have brought to light a more advanced tree-based algorithm, that is <strong>Random Forest</strong>, an ensemble method that combines multiple decision trees (that is why it is called “forest”) with the <strong>bagging</strong> technique, obtaining a more accurate and robust model.<br /><br /></p><h2 id=\"random-forest\">Random Forest</h2><p>The idea of <strong>bagging</strong> is to make prediction on <strong>N bootstrapped</strong> copies of the training set (i.e. sampled with replacement). In order to decorellate the trees, <strong>feature bagging</strong> is the best option. In particular, each time a split in a tree is considered, a fixed number of features (typically √p) is randomly chosen.</p><blockquote>  <p>p is the number of features of the given dataset</p></blockquote><p>The final prediction will be given by a <strong>majority voting scheme</strong> of all the estimators (or the <strong>average</strong>, in regression tasks).</p><p>This is why this algorithm is fairly <strong>robust</strong> to <strong>noise</strong> and <strong>outliers</strong> and will have much <strong>less variance</strong> rather than a single decision tree. It is robust to noise and outliers because the “impact” of these data points will be spread over all estimators and therefore their impact will decrease as the number of estimators increases. Then, it has a less variance because if we consider n observations with variance σ^2, the variance of the sample mean (over all estimators) will be exactly σ^2/n.</p><p><img src=\"http://localhost:4000/assets/images/decision-tree-random-forest/random_forest.jpg\" alt=\"RandomForest\" /></p><blockquote>  <p>Random Forest (<a href=\"https://www.tibco.com/reference-center/what-is-a-random-forest\">source</a>)</p></blockquote><p>On average, each bagged tree uses two third of the observation, therefore the remaining one third can be used to fit the given tree in order to evaluate its performances. This error is called <strong>out of bag error</strong> and sometimes it can be used for “stopping” the training procedure.</p><p>The million-dollar question is: <strong>how many trees do I need?</strong> I faced the same problem during my first trials. Intuitively, the higher is the number of estimators, the better will be the results BUT the improvements is not linear, therefore up to a certain point the computational complexity introduced will not be justified by its benefits.</p><p>When I was looking for the same answer I have found <a href=\"https://www.researchgate.net/publication/230766603_How_Many_Trees_in_a_Random_Forest\">this</a> paper that conducted an analysis on 29 different datasets and showed that “from 128 trees there is no more significant difference between the forests using 256, 512, 1024, 2048 and 4096 trees”.</p><p>Since we talked about the advantages we have to mention probably the main drawback : the <strong>computational cost</strong>. If we have limited resources, this algorithm may not be the perfect choice, especially if we have a large number of features and chosen estimators.<br /><br /></p><h2 id=\"conclusions\">Conclusions</h2><p>Today we went a bit deeper on the theory behind Decision Tree and Random Forest. Assuming that we have to select one of these two algorithms, we could say in a couple of lines that Decision Tree could be a valid option if we need to explain our model to non-experts or if we want to understand a bit what is going on inside our model. But, if we care only about the overall performances and we do not have any particular computational limitations, Random Forest should be preferred.</p><p>This was just the first part and soon or later I will post the second one, from which we will go through the implementation of both algorithms!</p><p>Thanks for reading the whole post and I hope it is all clear. If you still have some doubts or if you wanna just drop me a message, I would be more than happy to read it! Feel free to contact me on <a href=\"https://www.linkedin.com/in/francescodisalvo-pa/\">LinkedIn</a> :)<br /><br /></p><h2 id=\"references\">References</h2><ul>  <li>Wallpaper : https://unsplash.com/photos/7EqQ1s3wIAI</li>  <li>Gini vs Entropy : https://en.wikipedia.org/wiki/Recursive_partitioning</li>  <li>Bagging vs Boosting : https://quantdare.com/what-is-the-difference-between-bagging-and-boosting/</li>  <li>Number of trees in RF : https://www.researchgate.net/publication/230766603_How_Many_Trees_in_a_Random_Forest</li></ul>",
            "url": "http://localhost:4000/2021/10/03/decision-tree-random-forest-1",
            
            
            
            
            
            "date_published": "2021-10-03T00:00:00+00:00",
            "date_modified": "2021-10-03T00:00:00+00:00",
            
                "author":  {
                "name": "Ilya Semenov",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2021/09/14/fastapi-grocery-list",
            "title": "Fast API — How to build a grocery list",
            "summary": "Fast API — How to build a grocery list",
            "content_text": "  This article is also available on medium.I recently approached Fast API and I realized that is an extremely useful, powerful, and easy-to-use web framework. Compared to Flask, it is much faster because it is built over Asynchronous Server Gateway Interface (ASGI) instead of Web Server Gateway Interface (WSGI). You can read something more about it in the following medium article: “Difference between WSGI and ASGI?”.Today I explain a simple way for implementing a grocery list with FastAPI. Obviously, once you understand the basics of this framework, “the sky’s the limit!”First, we should start mentioning the CRUD operations, that are:  CREATE: create a new item  READ: retrieve all our items  UPDATE: update the quantity of a given item that we need to buy  DELETE: delete a given item  The code of this tutorial can be found in this repository.StructureThis is the structure that I have used in my repository:↳ app : init.py | app.py↳ test.py : init.py | test_main.pymain.pyGET, POST, PUT, DELETEThe foundations of the requests that took place on the web lie in Hypertext Transfer Protocol (HTTP). It manages all the communications between clients (the ones that request a resource) and servers (the ones that own the resources).Two of the most common HTTP methods are GET and POST. The major difference among them is that GET is used for requesting data to the server whereas POST is used for sending data to the server.If you want to know something more, I suggest you have a look at W3Schools. This website has been a bible for me while I was in high school and I was learning the Web Development stack.Moreover, we also have PUT and DELETE. PUT is used for updating an instance on the server whereas DELETE is used, as you may imagine, for deleting an existing item.API and JSONAn Application Programming Interface (API) is a software that allows the communication between two applications. JavaScript Object Notation (JSON), on the other hand, is a text format based on “key-value” pairs separated by commas. Here’s an example:{    \"name\" : \"Francesco\",    \"surname\" : \"Di Salvo\",    \"interests\" : [\"AI\",\"Data Science\",\"Finance\"]}The reason why I am mentioning them both together is that JSON is commonly used for communication among applications through APIs. The main advantage of using JSON is that it is easily parsed by the machines and interpreted by us!RequirementsTo facilitate you, I uploaded the requirements here. Therefore, once you have created your own virtual environment, you can simply install them with:pip install -r requirements.txtmain.pyHere we define our uvicorn server, which will run on localhost on port 8000. Notice that the option “reload=True” means that we are in debugging mode, Pay attention that it must be turned to False in production! It means that every time we change something on our code the server will be restarted.import uvicornif __name__ == '__main__':    uvicorn.run(\"app.app:app\", host=\"127.0.0.1\", port=8000, reload=True)app.py - CREATEHere the magic begins. First, we need to define our FastAPI application and then, we can start implementing our routes. For the sake of simplicity, we will not use any persistent memory but we will just use a list of dictionaries as our basket items.As we mentioned before, since we want to send data to the server we need to use a POST method. Now, we need to define an input dictionary, that will be sent from the client.From the input dictionary, we need the key-value pairs for the item and qty (quantity). Therefore, assuming the input keys are correct, we have two scenarios:  The item already exists: we raise a 400 error  The item does not exist: we add it to our list, and we send a 201 status code  For the status code you can also check this resource.from fastapi import FastAPI, HTTPExceptionapp = FastAPI()grocery_list = [    {\"item\" : \"bread\", \"qty\" : 1},    {\"item\" : \"milk\", \"qty\" : 2}]@app.post('/create', status_code=201)async def add_item(item : dict) -&gt; dict:    \"\"\"Creates a new item to buy    Args:        item (dict): {\"item\" : (str), \"qty\" : (int)}        Returns:        notification, code 201    Raises:        HTTPException 400, if the element is already present on the list    \"\"\"    for temp_item in grocery_list:        if temp_item['item'] == item['item']:            raise HTTPException(status_code=400, detail= f\"{item['item']} already present!\")    grocery_list.append(item)        return {\"data\" : f\"{item['item']} added correctly!\"}app.py - READNow, we want to define a route for reading all our inserted items. We do not need to send data on the network. Therefore, we can use a GET method. So, the associated method will simply return our list of dictionaries under the key data.@app.get('/list', status_code=200)async def get_list() -&gt; dict:    \"\"\"Gets the whole grocery list        Returns:        Dictionary containing the list of items under the key \"data\"    \"\"\"    return {\"data\":grocery_list}app.py — UPDATEThe third operation is UPDATE, for which we update the quantity of a given item already present on our current list. Recall from before that to update an instance we use the PUT method.Here we have the opposite situation of CREATE. We should raise an error if the item is not present on our list (because we cannot update it) and we can proceed otherwise.Instead of using a body, now we use two items that will be given through the URL. We are waiting for “item_name” and “item_quantity”.@app.put('/update', status_code=200)async def update_item(item_name:str, item_quantity:int) -&gt; dict:    \"\"\"Updates the quantity to buy for a given item    Args:        item_name (str) : name of the item to update        item_quantity (int) : quantity to update    Returns:        notification, code 200    Raises:         HTTPException 404, if the item is not present on the list    \"\"\"    for temp_item in grocery_list:        if temp_item['item'] == item_name:            temp_item['qty'] = item_quantity            return {\"data\" : f\"{item_name} correctly updated!\"}    raise HTTPException(status_code=404, detail=f\"{item_name} not found!\")view rawapp.py hosted with ❤ by GitHubapp.py — DELETEFinally, according to the CRUD paradigm we have to take care of the last operation, DELETE. Its corresponding method is DELETE, and we proceed as before. Now, instead of giving both “item_name” and “item_quantity” we give just “item_name”.However, to mess up everything a little bit, let’s see a different way for retrieving the item to delete. In particular, we may also give it in a parametric way through the route.For example, we may delete the item “water” by simply using the following request:/delete/waterTherefore, we use the name of the parameter inside the braces, and it can be used inside the method.@app.delete('/delete/{item_name}',status_code=200)async def delete_item(item_name:str) -&gt; dict:    \"\"\"Deletes item with a given iten_name    Args:        item_name (str) : name of the item that must be removed        Returns:        notification, code 200    Raises:        HTTPException 404, if the item is not present on the list    \"\"\"    for temp_item in grocery_list:        if temp_item['item'] == item_name:            grocery_list.remove(temp_item)            return {\"data\" : f\"{item_name} correctly deleted!\"}    raise HTTPException(status_code=404, detail=f\"{item_name} not found!\")TestingOnce we defined all these operations we may want to test them. There are several ways to do that and probably the most common way is through Postman. Alternatively, FastAPI provides a very intuitive GUI from the route /docs. Otherwise, we can always use our old friend pytest.To define methods recognized as tests, we have to call the python file with “test_fileToTest.py”, so we define our “test_main.py”. Then, each method will be called with “test_stuffToTest()”.For example, I want to test the creation of an item. We have two possibilities: the item already exists or not. Therefore, it is a common practice to test all the possible scenarios.from fastapi.testclient import TestClientfrom app.app import appclient = TestClient(app)def test_create_inexistent_item():    response = client.post(\"/create\", json={\"item\" : \"new_item\", \"qty\" : 10})    assert response.status_code == 201    assert response.json() == {\"data\" : \"new_item added correctly!\"}    def test_create_existent_item():    response = client.post(\"/create\", json={\"item\" : \"bread\", \"qty\" : 3})    assert response.status_code == 400    assert response.json() == {\"detail\" : \"bread already present!\"}You can check all the tests that I have already performed here. To run all the tests, you need to run:pytestSince I have performed 8 tests, this would be my result:ConclusionsToday we have seen how to build a simple local server that can be used for a lot of (more useful) use cases. Recently, I needed to build it for a coding interview, and to be honest, it was quite fun!I hope everything is clear, and if not, feel free to reach out on LinkedIn. I would be more than happy to hear your feedback!References  Wallpaper : https://unsplash.com/photos/8RaUEd8zD-U  Available code: https://github.com/francescodisalvo05/fastapi-grocery-list  GET and POST: https://www.w3schools.com/tags/ref_httpmethods.asp  APIs: https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces  Status code: https://fastapi.tiangolo.com/tutorial/response-status-code/  Postman: https://www.postman.com",
            "content_html": "<p><img src=\"http://localhost:4000/assets/images/fastapi-grocery-list/wallpaper.jpeg\" alt=\"Wallpaper\" /></p><blockquote>  <p>This article is also available on <a href=\"https://medium.com/artificialis/fast-api-how-to-build-a-grocery-list-ee51d65f5bf2\">medium</a>.</p></blockquote><p>I recently approached Fast API and I realized that is an extremely useful, powerful, and easy-to-use web framework. Compared to Flask, it is much faster because it is built over Asynchronous Server Gateway Interface (ASGI) instead of Web Server Gateway Interface (WSGI). You can read something more about it in the following medium article: “<a href=\"https://medium.com/analytics-vidhya/difference-between-wsgi-and-asgi-807158ed1d4c\">Difference between WSGI and ASGI?</a>”.</p><p>Today I explain a simple way for implementing a grocery list with FastAPI. Obviously, once you understand the basics of this framework, “the sky’s the limit!”</p><p>First, we should start mentioning the CRUD operations, that are:</p><ul>  <li>CREATE: create a new item</li>  <li>READ: retrieve all our items</li>  <li>UPDATE: update the quantity of a given item that we need to buy</li>  <li>DELETE: delete a given item</li></ul><p><br /></p><blockquote>  <p>The code of this tutorial can be found in <a href=\"https://github.com/francescodisalvo05/fastapi-grocery-list\">this</a> repository.</p></blockquote><p><br /><br /></p><h2 id=\"structure\">Structure</h2><p>This is the structure that I have used in my repository:↳ app : <strong>init</strong>.py | app.py↳ test.py : <strong>init</strong>.py | test_main.pymain.py</p><p><br /><br /></p><h2 id=\"get-post-put-delete\">GET, POST, PUT, DELETE</h2><p>The foundations of the requests that took place on the web lie in Hypertext Transfer Protocol (HTTP). It manages all the communications between <strong>clients</strong> (the ones that request a resource) and <strong>servers</strong> (the ones that own the resources).</p><p>Two of the most common <strong>HTTP</strong> methods are <strong>GET</strong> and <strong>POST</strong>. The major difference among them is that <strong>GET</strong> is used for requesting data to the server whereas POST is used for sending data to the server.</p><p>If you want to know something more, I suggest you have a look at <a href=\"https://www.w3schools.com/tags/ref_httpmethods.asp\">W3Schools</a>. This website has been a bible for me while I was in high school and I was learning the Web Development stack.</p><p>Moreover, we also have <strong>PUT</strong> and <strong>DELETE</strong>. PUT is used for updating an instance on the server whereas DELETE is used, as you may imagine, for deleting an existing item.<br /><br /></p><h2 id=\"api-and-json\">API and JSON</h2><p>An Application Programming Interface (API) is a software that allows the communication between two applications. JavaScript Object Notation (JSON), on the other hand, is a text format based on “key-value” pairs separated by commas. Here’s an example:</p><div class=\"language-json highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">{</span><span class=\"w\">    </span><span class=\"nl\">\"name\"</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Francesco\"</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"surname\"</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"Di Salvo\"</span><span class=\"p\">,</span><span class=\"w\">    </span><span class=\"nl\">\"interests\"</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s2\">\"AI\"</span><span class=\"p\">,</span><span class=\"s2\">\"Data Science\"</span><span class=\"p\">,</span><span class=\"s2\">\"Finance\"</span><span class=\"p\">]</span><span class=\"w\"></span><span class=\"p\">}</span><span class=\"w\"></span></code></pre></div></div><p>The reason why I am mentioning them both together is that JSON is commonly used for communication among applications through APIs. The main advantage of using JSON is that it is easily parsed by the machines and interpreted by us!<br /><br /></p><h2 id=\"requirements\">Requirements</h2><p>To facilitate you, I uploaded the requirements <a href=\"https://github.com/francescodisalvo05/fastapi-grocery-list/blob/main/requirements.txt\">here</a>. Therefore, once you have created your own virtual environment, you can simply install them with:</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"o\">-</span><span class=\"n\">r</span> <span class=\"n\">requirements</span><span class=\"p\">.</span><span class=\"n\">txt</span></code></pre></div></div><p><br /><br /></p><h2 id=\"mainpy\">main.py</h2><p>Here we define our <strong>uvicorn</strong> server, which will run on localhost on <strong>port 8000</strong>. Notice that the option “reload=True” means that we are in debugging mode, Pay attention that <strong>it must be turned to False in production</strong>! It means that every time we change something on our code the server will be restarted.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"nn\">uvicorn</span><span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"s\">'__main__'</span><span class=\"p\">:</span>    <span class=\"n\">uvicorn</span><span class=\"p\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"s\">\"app.app:app\"</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s\">\"127.0.0.1\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">8000</span><span class=\"p\">,</span> <span class=\"nb\">reload</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span></code></pre></div></div><p><br /><br /></p><h2 id=\"apppy---create\">app.py - CREATE</h2><p>Here the magic begins. First, we need to define our FastAPI application and then, we can start implementing our routes. For the sake of simplicity, we will not use any persistent memory but we will just use a list of dictionaries as our basket items.</p><p>As we mentioned before, since we want to send data to the server we need to use a POST method. Now, we need to define an input dictionary, that will be sent from the client.</p><p>From the input dictionary, we need the key-value pairs for the <strong>item</strong> and <strong>qty</strong> (quantity). Therefore, assuming the input keys are correct, we have two scenarios:</p><ol>  <li>The item already exists: we raise a 400 error</li>  <li>The item does not exist: we add it to our list, and we send a 201 status code</li></ol><blockquote>  <p>For the status code you can also check <a href=\"https://fastapi.tiangolo.com/tutorial/response-status-code/\">this</a> resource.</p></blockquote><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">fastapi</span> <span class=\"kn\">import</span> <span class=\"n\">FastAPI</span><span class=\"p\">,</span> <span class=\"n\">HTTPException</span><span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">FastAPI</span><span class=\"p\">()</span><span class=\"n\">grocery_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span>    <span class=\"p\">{</span><span class=\"s\">\"item\"</span> <span class=\"p\">:</span> <span class=\"s\">\"bread\"</span><span class=\"p\">,</span> <span class=\"s\">\"qty\"</span> <span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">},</span>    <span class=\"p\">{</span><span class=\"s\">\"item\"</span> <span class=\"p\">:</span> <span class=\"s\">\"milk\"</span><span class=\"p\">,</span> <span class=\"s\">\"qty\"</span> <span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span><span class=\"p\">]</span><span class=\"o\">@</span><span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"s\">'/create'</span><span class=\"p\">,</span> <span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">201</span><span class=\"p\">)</span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">add_item</span><span class=\"p\">(</span><span class=\"n\">item</span> <span class=\"p\">:</span> <span class=\"nb\">dict</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">dict</span><span class=\"p\">:</span>    <span class=\"s\">\"\"\"Creates a new item to buy    Args:        item (dict): {\"item\" : (str), \"qty\" : (int)}        Returns:        notification, code 201    Raises:        HTTPException 400, if the element is already present on the list    \"\"\"</span>    <span class=\"k\">for</span> <span class=\"n\">temp_item</span> <span class=\"ow\">in</span> <span class=\"n\">grocery_list</span><span class=\"p\">:</span>        <span class=\"k\">if</span> <span class=\"n\">temp_item</span><span class=\"p\">[</span><span class=\"s\">'item'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">item</span><span class=\"p\">[</span><span class=\"s\">'item'</span><span class=\"p\">]:</span>            <span class=\"k\">raise</span> <span class=\"n\">HTTPException</span><span class=\"p\">(</span><span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">400</span><span class=\"p\">,</span> <span class=\"n\">detail</span><span class=\"o\">=</span> <span class=\"sa\">f</span><span class=\"s\">\"</span><span class=\"si\">{</span><span class=\"n\">item</span><span class=\"p\">[</span><span class=\"s\">'item'</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s\"> already present!\"</span><span class=\"p\">)</span>    <span class=\"n\">grocery_list</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>        <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s\">\"data\"</span> <span class=\"p\">:</span> <span class=\"sa\">f</span><span class=\"s\">\"</span><span class=\"si\">{</span><span class=\"n\">item</span><span class=\"p\">[</span><span class=\"s\">'item'</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s\"> added correctly!\"</span><span class=\"p\">}</span></code></pre></div></div><p><br /><br /></p><h2 id=\"apppy---read\">app.py - READ</h2><p>Now, we want to define a route for reading all our inserted items. We do not need to send data on the network. Therefore, we can use a GET method. So, the associated method will simply return our list of dictionaries under the key data.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">'/list'</span><span class=\"p\">,</span> <span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">get_list</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">dict</span><span class=\"p\">:</span>    <span class=\"s\">\"\"\"Gets the whole grocery list        Returns:        Dictionary containing the list of items under the key \"data\"    \"\"\"</span>    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s\">\"data\"</span><span class=\"p\">:</span><span class=\"n\">grocery_list</span><span class=\"p\">}</span></code></pre></div></div><p><br /><br /></p><h2 id=\"apppy--update\">app.py — UPDATE</h2><p>The third operation is UPDATE, for which we update the quantity of a given item already present on our current list. Recall from before that to update an instance we use the PUT method.</p><p>Here we have the opposite situation of CREATE. We should raise an error if the item is not present on our list (because we cannot update it) and we can proceed otherwise.</p><p>Instead of using a body, now we use two items that will be given through the URL. We are waiting for “item_name” and “item_quantity”.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">put</span><span class=\"p\">(</span><span class=\"s\">'/update'</span><span class=\"p\">,</span> <span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">update_item</span><span class=\"p\">(</span><span class=\"n\">item_name</span><span class=\"p\">:</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">item_quantity</span><span class=\"p\">:</span><span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">dict</span><span class=\"p\">:</span>    <span class=\"s\">\"\"\"Updates the quantity to buy for a given item    Args:        item_name (str) : name of the item to update        item_quantity (int) : quantity to update    Returns:        notification, code 200    Raises:         HTTPException 404, if the item is not present on the list    \"\"\"</span>    <span class=\"k\">for</span> <span class=\"n\">temp_item</span> <span class=\"ow\">in</span> <span class=\"n\">grocery_list</span><span class=\"p\">:</span>        <span class=\"k\">if</span> <span class=\"n\">temp_item</span><span class=\"p\">[</span><span class=\"s\">'item'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">item_name</span><span class=\"p\">:</span>            <span class=\"n\">temp_item</span><span class=\"p\">[</span><span class=\"s\">'qty'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">item_quantity</span>            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s\">\"data\"</span> <span class=\"p\">:</span> <span class=\"sa\">f</span><span class=\"s\">\"</span><span class=\"si\">{</span><span class=\"n\">item_name</span><span class=\"si\">}</span><span class=\"s\"> correctly updated!\"</span><span class=\"p\">}</span>    <span class=\"k\">raise</span> <span class=\"n\">HTTPException</span><span class=\"p\">(</span><span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">404</span><span class=\"p\">,</span> <span class=\"n\">detail</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s\">\"</span><span class=\"si\">{</span><span class=\"n\">item_name</span><span class=\"si\">}</span><span class=\"s\"> not found!\"</span><span class=\"p\">)</span><span class=\"n\">view</span> <span class=\"n\">rawapp</span><span class=\"p\">.</span><span class=\"n\">py</span> <span class=\"n\">hosted</span> <span class=\"k\">with</span> <span class=\"err\">❤</span> <span class=\"n\">by</span> <span class=\"n\">GitHub</span></code></pre></div></div><p><br /><br /></p><h2 id=\"apppy--delete\">app.py — DELETE</h2><p>Finally, according to the CRUD paradigm we have to take care of the last operation, DELETE. Its corresponding method is DELETE, and we proceed as before. Now, instead of giving both “item_name” and “item_quantity” we give just “item_name”.</p><p>However, to mess up everything a little bit, let’s see a different way for retrieving the item to delete. In particular, we may also give it in a parametric way through the route.</p><p>For example, we may delete the item “water” by simply using the following request:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/delete/water</code></pre></div></div><p>Therefore, we use the name of the parameter inside the braces, and it can be used inside the method.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"o\">@</span><span class=\"n\">app</span><span class=\"p\">.</span><span class=\"n\">delete</span><span class=\"p\">(</span><span class=\"s\">'/delete/{item_name}'</span><span class=\"p\">,</span><span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">delete_item</span><span class=\"p\">(</span><span class=\"n\">item_name</span><span class=\"p\">:</span><span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">dict</span><span class=\"p\">:</span>    <span class=\"s\">\"\"\"Deletes item with a given iten_name    Args:        item_name (str) : name of the item that must be removed        Returns:        notification, code 200    Raises:        HTTPException 404, if the item is not present on the list    \"\"\"</span>    <span class=\"k\">for</span> <span class=\"n\">temp_item</span> <span class=\"ow\">in</span> <span class=\"n\">grocery_list</span><span class=\"p\">:</span>        <span class=\"k\">if</span> <span class=\"n\">temp_item</span><span class=\"p\">[</span><span class=\"s\">'item'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">item_name</span><span class=\"p\">:</span>            <span class=\"n\">grocery_list</span><span class=\"p\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">temp_item</span><span class=\"p\">)</span>            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s\">\"data\"</span> <span class=\"p\">:</span> <span class=\"sa\">f</span><span class=\"s\">\"</span><span class=\"si\">{</span><span class=\"n\">item_name</span><span class=\"si\">}</span><span class=\"s\"> correctly deleted!\"</span><span class=\"p\">}</span>    <span class=\"k\">raise</span> <span class=\"n\">HTTPException</span><span class=\"p\">(</span><span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">404</span><span class=\"p\">,</span> <span class=\"n\">detail</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s\">\"</span><span class=\"si\">{</span><span class=\"n\">item_name</span><span class=\"si\">}</span><span class=\"s\"> not found!\"</span><span class=\"p\">)</span></code></pre></div></div><p><br /><br /></p><h2 id=\"testing\">Testing</h2><p>Once we defined all these operations we may want to test them. There are several ways to do that and probably the most common way is through Postman. Alternatively, FastAPI provides a very intuitive GUI from the route /docs. Otherwise, we can always use our old friend pytest.</p><p>To define methods recognized as tests, we have to call the python file with “test_fileToTest.py”, so we define our “test_main.py”. Then, each method will be called with “test_stuffToTest()”.</p><p>For example, I want to test the creation of an item. We have two possibilities: the item already exists or not. Therefore, it is a common practice to test all the possible scenarios.</p><div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"nn\">fastapi.testclient</span> <span class=\"kn\">import</span> <span class=\"n\">TestClient</span><span class=\"kn\">from</span> <span class=\"nn\">app.app</span> <span class=\"kn\">import</span> <span class=\"n\">app</span><span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">TestClient</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span><span class=\"k\">def</span> <span class=\"nf\">test_create_inexistent_item</span><span class=\"p\">():</span>    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"s\">\"/create\"</span><span class=\"p\">,</span> <span class=\"n\">json</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s\">\"item\"</span> <span class=\"p\">:</span> <span class=\"s\">\"new_item\"</span><span class=\"p\">,</span> <span class=\"s\">\"qty\"</span> <span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">})</span>    <span class=\"k\">assert</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">status_code</span> <span class=\"o\">==</span> <span class=\"mi\">201</span>    <span class=\"k\">assert</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">json</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s\">\"data\"</span> <span class=\"p\">:</span> <span class=\"s\">\"new_item added correctly!\"</span><span class=\"p\">}</span>    <span class=\"k\">def</span> <span class=\"nf\">test_create_existent_item</span><span class=\"p\">():</span>    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">post</span><span class=\"p\">(</span><span class=\"s\">\"/create\"</span><span class=\"p\">,</span> <span class=\"n\">json</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s\">\"item\"</span> <span class=\"p\">:</span> <span class=\"s\">\"bread\"</span><span class=\"p\">,</span> <span class=\"s\">\"qty\"</span> <span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">})</span>    <span class=\"k\">assert</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">status_code</span> <span class=\"o\">==</span> <span class=\"mi\">400</span>    <span class=\"k\">assert</span> <span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">json</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s\">\"detail\"</span> <span class=\"p\">:</span> <span class=\"s\">\"bread already present!\"</span><span class=\"p\">}</span></code></pre></div></div><p>You can check all the tests that I have already performed <a href=\"https://github.com/francescodisalvo05/fastapi-grocery-list/blob/main/test/test_main.py\">here</a>. To run all the tests, you need to run:</p><div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pytest</code></pre></div></div><p>Since I have performed 8 tests, this would be my result:</p><p><img src=\"http://localhost:4000/assets/images/fastapi-grocery-list/pytest.png\" alt=\"Pytest\" /><br /><br /></p><h2 id=\"conclusions\">Conclusions</h2><p>Today we have seen how to build a simple local server that can be used for a lot of (more useful) use cases. Recently, I needed to build it for a coding interview, and to be honest, it was quite fun!</p><p>I hope everything is clear, and if not, feel free to reach out on <a href=\"https://www.linkedin.com/in/francescodisalvo-pa/\">LinkedIn</a>. I would be more than happy to hear your feedback!<br /><br /></p><h2 id=\"references\">References</h2><ul>  <li>Wallpaper : https://unsplash.com/photos/8RaUEd8zD-U</li>  <li>Available code: https://github.com/francescodisalvo05/fastapi-grocery-list</li>  <li>GET and POST: https://www.w3schools.com/tags/ref_httpmethods.asp</li>  <li>APIs: https://www.redhat.com/en/topics/api/what-are-application-programming-interfaces</li>  <li>Status code: https://fastapi.tiangolo.com/tutorial/response-status-code/</li>  <li>Postman: https://www.postman.com</li></ul>",
            "url": "http://localhost:4000/2021/09/14/fastapi-grocery-list",
            
            
            
            
            
            "date_published": "2021-09-14T00:00:00+00:00",
            "date_modified": "2021-09-14T00:00:00+00:00",
            
                "author":  {
                "name": "Ilya Semenov",
                "url": null,
                "avatar": null
                }
                
            
        },
    
        {
            "id": "http://localhost:4000/2021/09/06/curse-of-dimensionality",
            "title": "Curse of dimensionality",
            "summary": "What is the curse of dimensionality? And why is it so dangerous?",
            "content_text": "Curse of dimensionality  This article is also available on medium.IntroductionIf you have already gathered a bit of experience in Data Science and Machine Learning you’ve probably heard someone worried about the scary “curse of dimensionality”. If not, don’t panic, I will try to clarify it as much as I can!Most of the time, the definition of the curse of dimensionality is strictly related to the sparsity of the data. In fact, as the dimensionality increases, the volume of the space drastically increases as well, and the data becomes more and more sparse.A consequence of the sparsity of the dataset is that our machine learning algorithms will need way more data in order to generalize! However, it is not always so easy to gather labeled data. Therefore, it is way more efficient to tackle this problem from the beginning instead of looking for new data.From another perspectiveDuring my course of Mathematics in Machine Learning, the professor gave us a practical representation of this phenomenon that I have seen only in a few online resources.Let us consider a 2D feature space, represented by a unit square, and consider also a circle inscribed on this square. As you may see, most of the data points lie within the circle whereas the sparse data are on the corners.If we increase the dimension of the feature space by $1$, we obtain a unit cube and again a sphere inscribed. Intuitively, more points than before are sparse (i.e. are on the corners).  Please, close one eye and imagine that this cube has all the sides of the same length!Now, if we continue for a while, we will end up in a very high dimensional space. What happens? Well, the volume of the hypercube will be always one, whereas the volume of the hypersphere (also called n-ball, with n dimensions) will exponentially decrease. Therefore, always more and more points will lie on the corners!Are you still confused? Let’s try it mathematically. In two dimensions, given a unit square, its surface will be equal to 1 whreas the inscribed circle will have an area equal to 0.785\\[\\begin{cases}    X_2 = s \\times s = s^2 = 1^2 = 1\\\\    Y_2 = \\pi \\times r^2 = 3.14 \\times 0.25 = 0.785\\end{cases}\\]With three dimensions, we have:\\[\\begin{cases}    X_3 = s \\times s \\times s = s^3 = 1^3 = 1 \\\\    Y_3 = \\frac 4 3 \\times \\pi \\times r^3 = 1.33 \\times 3.14 \\times 0.125 = 0.785\\end{cases}\\]Finally, with n dimensions, we have\\[\\begin{cases}    X_n = s^n = 1 \\\\    Y_n = \\frac { \\pi^{n/2} } { \\Gamma (\\frac n 2 + 1)} ( \\frac 1 2 )^2\\end{cases}\\]  See wikipedia for the volume of the “n-ball”Hopefully now, you should be able to “see” and understand the relationship between the number of dimensions and the sparsity of the data!What about the distance metrics?Well, some distance metrics may be strongly affected by this phenomenon. In particular the euclidean distance will slowly lose its relevance as the number of dimensions increases.Why? Well, first, recall the definition of the euclidean distance with d dimensions:\\[D(x,y) = \\sum_{i=1}^d (x_i - y_i)^2\\]As you can imagine, if you start adding new dimensions, this sum will increases as well. Therefore, for a sufficiently large number of dimensions the ratio among the nearest and the farthest point approaches 1. Hence, it doesn’t make any sense to speak about “K” nearest points (e.g. in KNN, LOF and so on).ConclusionsTo sum up, we have tried to give a more formal explanation to the curse of dimensionality, a very argued and underestimated topic in Machine Learning.Whenever we have a very high number of features, we have several options that can be taken into account, for example:  Remove highly correlated or non correlated features  Group similar features  Use Principal Components Analysis and similar techniquesReferences  Background Photo by Sigmund on Unsplash  Curse of dimensionality : Wikipedia  The course of dimensionality : Julie Delon  The curse of dimensionality : Tony YiU",
            "content_html": "<h1 id=\"curse-of-dimensionality\">Curse of dimensionality</h1><p><img src=\"http://localhost:4000/assets/images/curse-of-dimensionality/background.jpg\" alt=\"Wallpaper\" /></p><blockquote>  <p>This article is also available on <a href=\"https://medium.com/geekculture/curse-of-dimensionality-e97ba916cb8f\">medium</a>.</p></blockquote><p><br /></p><h2 id=\"introduction\">Introduction</h2><p>If you have already gathered a bit of experience in Data Science and Machine Learning you’ve probably heard someone worried about the scary “<strong>curse of dimensionality</strong>”. If not, don’t panic, I will try to clarify it as much as I can!</p><p>Most of the time, the definition of the curse of dimensionality is strictly related to the <strong>sparsity</strong> of the data. In fact, as the dimensionality increases, the volume of the space drastically increases as well, and the data becomes more and more sparse.</p><p>A consequence of the sparsity of the dataset is that our machine learning algorithms will need way more data in order to <strong>generalize</strong>! However, it is not always so easy to gather labeled data. Therefore, it is way more efficient to tackle this problem from the beginning instead of looking for new data.</p><p><br /></p><h2 id=\"from-another-perspective\">From another perspective</h2><p>During my course of Mathematics in Machine Learning, the professor gave us a practical representation of this phenomenon that I have seen only in a few online resources.</p><p>Let us consider a 2D feature space, represented by a <strong>unit square</strong>, and consider also a <strong>circle inscribed on this square</strong>. As you may see, most of the data points lie within the circle whereas the sparse data are on the corners.</p><p><img src=\"http://localhost:4000/assets/images/curse-of-dimensionality/surface.jpg\" alt=\"Surface\" /></p><p>If we increase the dimension of the feature space by $1$, we obtain a <strong>unit cube</strong> and again a <strong>sphere inscribed</strong>. Intuitively, more points than before are sparse (i.e. are on the corners).</p><p><img src=\"http://localhost:4000/assets/images/curse-of-dimensionality/volume.jpg\" alt=\"Volume\" /></p><blockquote>  <p>Please, close one eye and imagine that this cube has all the sides of the same length!</p></blockquote><p>Now, if we continue for a while, we will end up in a very high dimensional space. What happens? Well, the volume of the hypercube will be always one, whereas the volume of the hypersphere (also called n-ball, with n dimensions) will exponentially decrease. Therefore, always more and more points will lie on the corners!</p><p>Are you still confused? Let’s try it mathematically. In two dimensions, given a unit square, its surface will be equal to 1 whreas the inscribed circle will have an area equal to 0.785</p>\\[\\begin{cases}    X_2 = s \\times s = s^2 = 1^2 = 1\\\\    Y_2 = \\pi \\times r^2 = 3.14 \\times 0.25 = 0.785\\end{cases}\\]<p>With three dimensions, we have:</p>\\[\\begin{cases}    X_3 = s \\times s \\times s = s^3 = 1^3 = 1 \\\\    Y_3 = \\frac 4 3 \\times \\pi \\times r^3 = 1.33 \\times 3.14 \\times 0.125 = 0.785\\end{cases}\\]<p><img src=\"http://localhost:4000/assets/images/curse-of-dimensionality/surface-volume.jpg\" alt=\"Surface-and-Volume\" /></p><p>Finally, with <em>n</em> dimensions, we have</p>\\[\\begin{cases}    X_n = s^n = 1 \\\\    Y_n = \\frac { \\pi^{n/2} } { \\Gamma (\\frac n 2 + 1)} ( \\frac 1 2 )^2\\end{cases}\\]<blockquote>  <p>See wikipedia for the volume of the “n-ball”</p></blockquote><p>Hopefully now, you should be able to “see” and understand the relationship between the number of dimensions and the sparsity of the data!</p><p><br /></p><h2 id=\"what-about-the-distance-metrics\">What about the distance metrics?</h2><p>Well, some distance metrics may be strongly affected by this phenomenon. In particular the euclidean distance will slowly lose its relevance as the number of dimensions increases.</p><p>Why? Well, first, recall the definition of the euclidean distance with <em>d</em> dimensions:</p>\\[D(x,y) = \\sum_{i=1}^d (x_i - y_i)^2\\]<p>As you can imagine, if you start adding new dimensions, this sum will increases as well. Therefore, for a sufficiently large number of dimensions the ratio among the nearest and the farthest point approaches 1. Hence, it doesn’t make any sense to speak about “K” nearest points (e.g. in KNN, LOF and so on).</p><p><br /></p><h2 id=\"conclusions\">Conclusions</h2><p>To sum up, we have tried to give a more formal explanation to the curse of dimensionality, a very argued and underestimated topic in Machine Learning.</p><p>Whenever we have a very high number of features, we have several options that can be taken into account, for example:</p><ul>  <li>Remove highly <a href=\"https://en.wikipedia.org/wiki/Pearson_correlation_coefficient\">correlated</a> or non correlated features</li>  <li>Group similar features</li>  <li>Use <a href=\"https://en.wikipedia.org/wiki/Principal_component_analysis\">Principal Components Analysis</a> and similar techniques</li></ul><p><br /></p><h2 id=\"references\">References</h2><ul>  <li>Background Photo by <a href=\"https://unsplash.com/@sigmund?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Sigmund</a> on <a href=\"https://unsplash.com/s/photos/glasses-3d?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\">Unsplash</a></li>  <li>Curse of dimensionality : <a href=\"https://en.wikipedia.org/wiki/Curse_of_dimensionality\">Wikipedia</a></li>  <li>The course of dimensionality : <a href=\"https://mathematical-coffees.github.io/slides/mc08-delon.pdf\">Julie Delon</a></li>  <li>The curse of dimensionality : <a href=\"https://towardsdatascience.com/the-curse-of-dimensionality-50dc6e49aa1e\">Tony YiU</a></li></ul>",
            "url": "http://localhost:4000/2021/09/06/curse-of-dimensionality",
            
            
            
            
            
            "date_published": "2021-09-06T00:00:00+00:00",
            "date_modified": "2021-09-06T00:00:00+00:00",
            
                "author":  {
                "name": "Ilya Semenov",
                "url": null,
                "avatar": null
                }
                
            
        }
    
    ]
}